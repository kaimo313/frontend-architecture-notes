## 对比（协商）缓存

比较一下再去决定是用缓存还是重新获取数据，这样会减少网络请求，提高性能。

## 对比缓存的工作原理

客户端第一次请求服务器的时候，服务器会把数据进行缓存，同时会生成一个缓存标识符，这个缓存标识符会被发送到客户端，客户端第二次请求服务器的时候，会把缓存标识符发送到服务器，服务器会根据缓存标识符进行判断，如果缓存标识符相同，则服务器会判断缓存是否过期，如果没有过期，则服务器会返回 304，告诉客户端使用缓存，如果缓存标识符不同，则服务器会返回 200，同时返回新的数据。

上一节使用了修改时间的方式，这一节用内容来处理

使用 md5 摘要算法：不是加密算法（不可逆）

- 不可逆
- 不同内容转化的结果不相同
- 转化后的结果都是一样长的
- 同样的东西产生的结果肯定是相同的
- 雪崩效应，一点不同翻天覆地不同

使用的库是 crypto 这个库

```js
const crypto = require('crypto');
console.log(crypto.createHash('md5').update('kaimo313').digest('base64'));
// rFDqro5Lox3vFXr5fA4r7Q==
```

- 客户端：`if-none-match`
- 服务端：`ETag` 当前文件唯一标识

`ETag + if-none-match` 可以实现对比缓存，比较的方式比较精准，缺点是文件很大性能就很差，但是默认我们不会完整内容生成 hash 戳，可以取文件的某一部分，为了保证精确度，可采用内容的一部分加上文件的总大小来生成 hash 戳，这样性能会好很多。
